# Lecture 2

### Что будет, если внести тип Bool

- Попробуйте переписать все правила подходящим образом

```
I                       [[I]] = int
B                       [[B]] = Bool
E1 eqOp E2              [[E1]] = [[E2]] ∧ [[E1 eqOp E2]] = Bool
E1 compOp E2            [[E1]] = [[E2]] ∧ [[E1 compOp E2]] = Bool
E1 logOp E2             [[E1]] = [[E2]] = [[E1 logOp E2]] = Bool
E1 op E2                [[E1]] = [[E2]] = [[E1 op E2]] = int
input                   [[input]] = α
X = E                   [[X]] = [[E]]
output E                [[E]] = α
if(E) {S}               [[E]] = Bool
if(E) {S1} else {S2}    [[E]] = Bool
while(E) {S}            [[E]] = Bool
...
```

- Будет ли анализ более полным?

Анализ стал менее полным, так как такие правила не совпадают с валидными конструкциями языка. Например, язык допускает
int в условии if-else или цикла.

- Будет ли анализ более точным?

Точность не изменится. Если анализ успешно выводит тип, то он точно правильный, как и было до этого (soundness).

### Что будет, если в нашу систему ввести тип Array

- Придумайте правила вывода для новых операторов

```
{}                   [[{}]] = α[]
{E1, ..., EN}        [[{E1, ..., EN}]] = [[E1]][] ^ [[E1]] = ... = [[EN]]
A[E]                 [[A[E]]] = α ^ [[E]] = int ^ [[A]] = α[]
A[E1] = E2           [[E2]] = α ^ [[E1]] = int ^ [[A[E1]]] = [[E2]] ^ [[A]] = α[]
```

- Попробуйте протипизировать программу со слайда

```
main() {                    [[main]] = () → ()
var x,y,z,t;
x = {2,4,8,16,32,64};       [[x]] = [[{2,4,8,16,32,64}]] ^ [[2]] = ... = [[64]]         // = int[]
y = x[x[3]];                [[y]] = ([[ x[x[3]] ]] = α_x ^ [[ x[3] ]] = int ^ [[x]] = α_x[]) ^ [[x[3]]] = α_x3 ^ [[3]] = int ^ [[x]] = α_x3[]
z = {{},x};                 [[z]] = [[{{},x}]] ^ [[{}]] = [[x]]
t = z[1];                   [[t]] = ([[ z[1] ]] = α_z ^ [[z]] = α_z[])
t[2] = y;                   [[y]] = α_t ^ [[ t[2] ]] = [[y]] ^ [[t]] = α_t[]
}
```

Решение:
```
[[x]] = int[]      [[a_x]] = int  [[a_x3]] = int
[[y]] = int          
[[z]] = int[][]     a_z = int[]
[[t]] = int[]       a_t = int
```

### Подумайте, что происходит в получившейся реализации, если в программе есть рекурсивный тип?

Используемый солвер основан на union find и позволяет регулярные рекурсивные термы. 